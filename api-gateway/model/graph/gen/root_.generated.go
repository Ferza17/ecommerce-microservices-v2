// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gen

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gen "github.com/ferza17/ecommerce-microservices-v2/api-gateway/model/rpc/gen/commerce/v1"
	gen3 "github.com/ferza17/ecommerce-microservices-v2/api-gateway/model/rpc/gen/payment/v1"
	gen1 "github.com/ferza17/ecommerce-microservices-v2/api-gateway/model/rpc/gen/product/v1"
	gen2 "github.com/ferza17/ecommerce-microservices-v2/api-gateway/model/rpc/gen/user/v1"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	CartItem() CartItemResolver
	Mutation() MutationResolver
	Payment() PaymentResolver
	PaymentItem() PaymentItemResolver
	Product() ProductResolver
	Provider() ProviderResolver
	Query() QueryResolver
	User() UserResolver
	CreatePaymentRequest() CreatePaymentRequestResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CartItem struct {
		CratedAt  func(childComplexity int) int
		Id        func(childComplexity int) int
		Price     func(childComplexity int) int
		Product   func(childComplexity int) int
		ProductId func(childComplexity int) int
		Qty       func(childComplexity int) int
		UpdatedAt func(childComplexity int) int
		User      func(childComplexity int) int
		UserId    func(childComplexity int) int
	}

	CreateCartItemResponse struct {
		Id func(childComplexity int) int
	}

	CreateProductResponse struct {
		Id func(childComplexity int) int
	}

	CreateUserResponse struct {
		Id func(childComplexity int) int
	}

	DeleteCartItemResponse struct {
		UserID func(childComplexity int) int
	}

	DeleteProductByIdResponse struct {
		Message func(childComplexity int) int
	}

	FindCartItemsWithPaginationResponse struct {
		Items func(childComplexity int) int
		Limit func(childComplexity int) int
		Page  func(childComplexity int) int
	}

	FindPaymentProvidersResponse struct {
		Data func(childComplexity int) int
	}

	FindProductsWithPaginationResponse struct {
		Data  func(childComplexity int) int
		Limit func(childComplexity int) int
		Page  func(childComplexity int) int
		Total func(childComplexity int) int
	}

	Mutation struct {
		CreateCartItem     func(childComplexity int, input *gen.CreateCartItemRequest) int
		CreateProduct      func(childComplexity int, input gen1.CreateProductRequest) int
		CreateUser         func(childComplexity int, input gen2.CreateUserRequest) int
		DeleteCartItem     func(childComplexity int, input *DeleteCartItemRequest) int
		DeleteProductByID  func(childComplexity int, id string) int
		UpdateCartItemByID func(childComplexity int, input *gen.UpdateCartItemByIdRequest) int
		UpdateProductByID  func(childComplexity int, input gen1.UpdateProductByIdRequest) int
		UpdateUserByID     func(childComplexity int, input gen2.UpdateUserByIdRequest) int
	}

	Payment struct {
		Code        func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		Id          func(childComplexity int) int
		Items       func(childComplexity int) int
		Provider    func(childComplexity int) int
		Status      func(childComplexity int) int
		TotalPrice  func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		UserId      func(childComplexity int) int
	}

	PaymentItem struct {
		Amount      func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		Id          func(childComplexity int) int
		ProductId   func(childComplexity int) int
		Qty         func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Product struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		Id          func(childComplexity int) int
		Image       func(childComplexity int) int
		Name        func(childComplexity int) int
		Price       func(childComplexity int) int
		Stock       func(childComplexity int) int
		Uom         func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Provider struct {
		CreatedAt   func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		Id          func(childComplexity int) int
		Method      func(childComplexity int) int
		Name        func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Query struct {
		FindCartItemsWithPagination  func(childComplexity int, input *gen.FindCartItemsWithPaginationRequest) int
		FindPaymentByID              func(childComplexity int, id string) int
		FindPaymentByUserIDAndStatus func(childComplexity int, userID string, status gen3.PaymentStatus) int
		FindPaymentProviders         func(childComplexity int, input *gen3.FindPaymentProvidersRequest) int
		FindProductByID              func(childComplexity int, id string) int
		FindProductsWithPagination   func(childComplexity int, filter gen1.FindProductsWithPaginationRequest) int
		FindUserByEmailAndPassword   func(childComplexity int, input gen2.FindUserByEmailAndPasswordRequest) int
		FindUserByID                 func(childComplexity int, id string) int
	}

	UpdateCartItemByIdResponse struct {
		Id func(childComplexity int) int
	}

	UpdateUserByIdResponse struct {
		Id func(childComplexity int) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		Email       func(childComplexity int) int
		Id          func(childComplexity int) int
		Name        func(childComplexity int) int
		Password    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CartItem.crated_at":
		if e.complexity.CartItem.CratedAt == nil {
			break
		}

		return e.complexity.CartItem.CratedAt(childComplexity), true

	case "CartItem.id":
		if e.complexity.CartItem.Id == nil {
			break
		}

		return e.complexity.CartItem.Id(childComplexity), true

	case "CartItem.price":
		if e.complexity.CartItem.Price == nil {
			break
		}

		return e.complexity.CartItem.Price(childComplexity), true

	case "CartItem.product":
		if e.complexity.CartItem.Product == nil {
			break
		}

		return e.complexity.CartItem.Product(childComplexity), true

	case "CartItem.productId":
		if e.complexity.CartItem.ProductId == nil {
			break
		}

		return e.complexity.CartItem.ProductId(childComplexity), true

	case "CartItem.qty":
		if e.complexity.CartItem.Qty == nil {
			break
		}

		return e.complexity.CartItem.Qty(childComplexity), true

	case "CartItem.updated_at":
		if e.complexity.CartItem.UpdatedAt == nil {
			break
		}

		return e.complexity.CartItem.UpdatedAt(childComplexity), true

	case "CartItem.user":
		if e.complexity.CartItem.User == nil {
			break
		}

		return e.complexity.CartItem.User(childComplexity), true

	case "CartItem.userId":
		if e.complexity.CartItem.UserId == nil {
			break
		}

		return e.complexity.CartItem.UserId(childComplexity), true

	case "CreateCartItemResponse.id":
		if e.complexity.CreateCartItemResponse.Id == nil {
			break
		}

		return e.complexity.CreateCartItemResponse.Id(childComplexity), true

	case "CreateProductResponse.id":
		if e.complexity.CreateProductResponse.Id == nil {
			break
		}

		return e.complexity.CreateProductResponse.Id(childComplexity), true

	case "CreateUserResponse.id":
		if e.complexity.CreateUserResponse.Id == nil {
			break
		}

		return e.complexity.CreateUserResponse.Id(childComplexity), true

	case "DeleteCartItemResponse.userId":
		if e.complexity.DeleteCartItemResponse.UserID == nil {
			break
		}

		return e.complexity.DeleteCartItemResponse.UserID(childComplexity), true

	case "DeleteProductByIdResponse.message":
		if e.complexity.DeleteProductByIdResponse.Message == nil {
			break
		}

		return e.complexity.DeleteProductByIdResponse.Message(childComplexity), true

	case "FindCartItemsWithPaginationResponse.items":
		if e.complexity.FindCartItemsWithPaginationResponse.Items == nil {
			break
		}

		return e.complexity.FindCartItemsWithPaginationResponse.Items(childComplexity), true

	case "FindCartItemsWithPaginationResponse.limit":
		if e.complexity.FindCartItemsWithPaginationResponse.Limit == nil {
			break
		}

		return e.complexity.FindCartItemsWithPaginationResponse.Limit(childComplexity), true

	case "FindCartItemsWithPaginationResponse.page":
		if e.complexity.FindCartItemsWithPaginationResponse.Page == nil {
			break
		}

		return e.complexity.FindCartItemsWithPaginationResponse.Page(childComplexity), true

	case "FindPaymentProvidersResponse.data":
		if e.complexity.FindPaymentProvidersResponse.Data == nil {
			break
		}

		return e.complexity.FindPaymentProvidersResponse.Data(childComplexity), true

	case "FindProductsWithPaginationResponse.data":
		if e.complexity.FindProductsWithPaginationResponse.Data == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Data(childComplexity), true

	case "FindProductsWithPaginationResponse.limit":
		if e.complexity.FindProductsWithPaginationResponse.Limit == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Limit(childComplexity), true

	case "FindProductsWithPaginationResponse.page":
		if e.complexity.FindProductsWithPaginationResponse.Page == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Page(childComplexity), true

	case "FindProductsWithPaginationResponse.total":
		if e.complexity.FindProductsWithPaginationResponse.Total == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Total(childComplexity), true

	case "Mutation.createCartItem":
		if e.complexity.Mutation.CreateCartItem == nil {
			break
		}

		args, err := ec.field_Mutation_createCartItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateCartItem(childComplexity, args["input"].(*gen.CreateCartItemRequest)), true

	case "Mutation.createProduct":
		if e.complexity.Mutation.CreateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_createProduct_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProduct(childComplexity, args["input"].(gen1.CreateProductRequest)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(gen2.CreateUserRequest)), true

	case "Mutation.deleteCartItem":
		if e.complexity.Mutation.DeleteCartItem == nil {
			break
		}

		args, err := ec.field_Mutation_deleteCartItem_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteCartItem(childComplexity, args["input"].(*DeleteCartItemRequest)), true

	case "Mutation.deleteProductById":
		if e.complexity.Mutation.DeleteProductByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProductById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProductByID(childComplexity, args["id"].(string)), true

	case "Mutation.updateCartItemById":
		if e.complexity.Mutation.UpdateCartItemByID == nil {
			break
		}

		args, err := ec.field_Mutation_updateCartItemById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateCartItemByID(childComplexity, args["input"].(*gen.UpdateCartItemByIdRequest)), true

	case "Mutation.updateProductById":
		if e.complexity.Mutation.UpdateProductByID == nil {
			break
		}

		args, err := ec.field_Mutation_updateProductById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProductByID(childComplexity, args["input"].(gen1.UpdateProductByIdRequest)), true

	case "Mutation.updateUserById":
		if e.complexity.Mutation.UpdateUserByID == nil {
			break
		}

		args, err := ec.field_Mutation_updateUserById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateUserByID(childComplexity, args["input"].(gen2.UpdateUserByIdRequest)), true

	case "Payment.code":
		if e.complexity.Payment.Code == nil {
			break
		}

		return e.complexity.Payment.Code(childComplexity), true

	case "Payment.createdAt":
		if e.complexity.Payment.CreatedAt == nil {
			break
		}

		return e.complexity.Payment.CreatedAt(childComplexity), true

	case "Payment.discardedAt":
		if e.complexity.Payment.DiscardedAt == nil {
			break
		}

		return e.complexity.Payment.DiscardedAt(childComplexity), true

	case "Payment.id":
		if e.complexity.Payment.Id == nil {
			break
		}

		return e.complexity.Payment.Id(childComplexity), true

	case "Payment.items":
		if e.complexity.Payment.Items == nil {
			break
		}

		return e.complexity.Payment.Items(childComplexity), true

	case "Payment.provider":
		if e.complexity.Payment.Provider == nil {
			break
		}

		return e.complexity.Payment.Provider(childComplexity), true

	case "Payment.status":
		if e.complexity.Payment.Status == nil {
			break
		}

		return e.complexity.Payment.Status(childComplexity), true

	case "Payment.totalPrice":
		if e.complexity.Payment.TotalPrice == nil {
			break
		}

		return e.complexity.Payment.TotalPrice(childComplexity), true

	case "Payment.updatedAt":
		if e.complexity.Payment.UpdatedAt == nil {
			break
		}

		return e.complexity.Payment.UpdatedAt(childComplexity), true

	case "Payment.userId":
		if e.complexity.Payment.UserId == nil {
			break
		}

		return e.complexity.Payment.UserId(childComplexity), true

	case "PaymentItem.amount":
		if e.complexity.PaymentItem.Amount == nil {
			break
		}

		return e.complexity.PaymentItem.Amount(childComplexity), true

	case "PaymentItem.createdAt":
		if e.complexity.PaymentItem.CreatedAt == nil {
			break
		}

		return e.complexity.PaymentItem.CreatedAt(childComplexity), true

	case "PaymentItem.discardedAt":
		if e.complexity.PaymentItem.DiscardedAt == nil {
			break
		}

		return e.complexity.PaymentItem.DiscardedAt(childComplexity), true

	case "PaymentItem.id":
		if e.complexity.PaymentItem.Id == nil {
			break
		}

		return e.complexity.PaymentItem.Id(childComplexity), true

	case "PaymentItem.productId":
		if e.complexity.PaymentItem.ProductId == nil {
			break
		}

		return e.complexity.PaymentItem.ProductId(childComplexity), true

	case "PaymentItem.qty":
		if e.complexity.PaymentItem.Qty == nil {
			break
		}

		return e.complexity.PaymentItem.Qty(childComplexity), true

	case "PaymentItem.updatedAt":
		if e.complexity.PaymentItem.UpdatedAt == nil {
			break
		}

		return e.complexity.PaymentItem.UpdatedAt(childComplexity), true

	case "Product.createdAt":
		if e.complexity.Product.CreatedAt == nil {
			break
		}

		return e.complexity.Product.CreatedAt(childComplexity), true

	case "Product.description":
		if e.complexity.Product.Description == nil {
			break
		}

		return e.complexity.Product.Description(childComplexity), true

	case "Product.discardedAt":
		if e.complexity.Product.DiscardedAt == nil {
			break
		}

		return e.complexity.Product.DiscardedAt(childComplexity), true

	case "Product.id":
		if e.complexity.Product.Id == nil {
			break
		}

		return e.complexity.Product.Id(childComplexity), true

	case "Product.image":
		if e.complexity.Product.Image == nil {
			break
		}

		return e.complexity.Product.Image(childComplexity), true

	case "Product.name":
		if e.complexity.Product.Name == nil {
			break
		}

		return e.complexity.Product.Name(childComplexity), true

	case "Product.price":
		if e.complexity.Product.Price == nil {
			break
		}

		return e.complexity.Product.Price(childComplexity), true

	case "Product.stock":
		if e.complexity.Product.Stock == nil {
			break
		}

		return e.complexity.Product.Stock(childComplexity), true

	case "Product.uom":
		if e.complexity.Product.Uom == nil {
			break
		}

		return e.complexity.Product.Uom(childComplexity), true

	case "Product.updatedAt":
		if e.complexity.Product.UpdatedAt == nil {
			break
		}

		return e.complexity.Product.UpdatedAt(childComplexity), true

	case "Provider.createdAt":
		if e.complexity.Provider.CreatedAt == nil {
			break
		}

		return e.complexity.Provider.CreatedAt(childComplexity), true

	case "Provider.discardedAt":
		if e.complexity.Provider.DiscardedAt == nil {
			break
		}

		return e.complexity.Provider.DiscardedAt(childComplexity), true

	case "Provider.id":
		if e.complexity.Provider.Id == nil {
			break
		}

		return e.complexity.Provider.Id(childComplexity), true

	case "Provider.method":
		if e.complexity.Provider.Method == nil {
			break
		}

		return e.complexity.Provider.Method(childComplexity), true

	case "Provider.name":
		if e.complexity.Provider.Name == nil {
			break
		}

		return e.complexity.Provider.Name(childComplexity), true

	case "Provider.updatedAt":
		if e.complexity.Provider.UpdatedAt == nil {
			break
		}

		return e.complexity.Provider.UpdatedAt(childComplexity), true

	case "Query.findCartItemsWithPagination":
		if e.complexity.Query.FindCartItemsWithPagination == nil {
			break
		}

		args, err := ec.field_Query_findCartItemsWithPagination_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindCartItemsWithPagination(childComplexity, args["input"].(*gen.FindCartItemsWithPaginationRequest)), true

	case "Query.findPaymentById":
		if e.complexity.Query.FindPaymentByID == nil {
			break
		}

		args, err := ec.field_Query_findPaymentById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindPaymentByID(childComplexity, args["id"].(string)), true

	case "Query.findPaymentByUserIdAndStatus":
		if e.complexity.Query.FindPaymentByUserIDAndStatus == nil {
			break
		}

		args, err := ec.field_Query_findPaymentByUserIdAndStatus_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindPaymentByUserIDAndStatus(childComplexity, args["userId"].(string), args["status"].(gen3.PaymentStatus)), true

	case "Query.findPaymentProviders":
		if e.complexity.Query.FindPaymentProviders == nil {
			break
		}

		args, err := ec.field_Query_findPaymentProviders_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindPaymentProviders(childComplexity, args["input"].(*gen3.FindPaymentProvidersRequest)), true

	case "Query.findProductById":
		if e.complexity.Query.FindProductByID == nil {
			break
		}

		args, err := ec.field_Query_findProductById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindProductByID(childComplexity, args["id"].(string)), true

	case "Query.findProductsWithPagination":
		if e.complexity.Query.FindProductsWithPagination == nil {
			break
		}

		args, err := ec.field_Query_findProductsWithPagination_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindProductsWithPagination(childComplexity, args["filter"].(gen1.FindProductsWithPaginationRequest)), true

	case "Query.findUserByEmailAndPassword":
		if e.complexity.Query.FindUserByEmailAndPassword == nil {
			break
		}

		args, err := ec.field_Query_findUserByEmailAndPassword_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUserByEmailAndPassword(childComplexity, args["input"].(gen2.FindUserByEmailAndPasswordRequest)), true

	case "Query.findUserById":
		if e.complexity.Query.FindUserByID == nil {
			break
		}

		args, err := ec.field_Query_findUserById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUserByID(childComplexity, args["id"].(string)), true

	case "UpdateCartItemByIdResponse.id":
		if e.complexity.UpdateCartItemByIdResponse.Id == nil {
			break
		}

		return e.complexity.UpdateCartItemByIdResponse.Id(childComplexity), true

	case "UpdateUserByIdResponse.id":
		if e.complexity.UpdateUserByIdResponse.Id == nil {
			break
		}

		return e.complexity.UpdateUserByIdResponse.Id(childComplexity), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.discardedAt":
		if e.complexity.User.DiscardedAt == nil {
			break
		}

		return e.complexity.User.DiscardedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.Id == nil {
			break
		}

		return e.complexity.User.Id(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCallBackPaymentRequest,
		ec.unmarshalInputCreateCartItemRequest,
		ec.unmarshalInputCreatePaymentRequest,
		ec.unmarshalInputCreateProductRequest,
		ec.unmarshalInputCreateUserRequest,
		ec.unmarshalInputDeleteCartItemRequest,
		ec.unmarshalInputFindCartItemsWithPaginationRequest,
		ec.unmarshalInputFindPaymentByIdRequest,
		ec.unmarshalInputFindPaymentByUserIdAndStatusRequest,
		ec.unmarshalInputFindPaymentProvidersRequest,
		ec.unmarshalInputFindProductsWithPaginationRequest,
		ec.unmarshalInputFindUserByEmailAndPasswordRequest,
		ec.unmarshalInputPaymentItemInput,
		ec.unmarshalInputUpdateCartItemByIdRequest,
		ec.unmarshalInputUpdateProductByIdRequest,
		ec.unmarshalInputUpdateUserByIdRequest,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/commerce/cart/v1/cart.graphqls", Input: `type CartItem {
    id: String
    productId: String
    product: Product
    userId: String
    user: User
    qty: Int
    price: Float
    crated_at: Time
    updated_at: Time
}

input CreateCartItemRequest {
    productId: String
    userId: String
    qty: Int
    price: Float
}

type CreateCartItemResponse {
    id: String
}

input UpdateCartItemByIdRequest {
    id: String
    productId: String
    userId: String
    qty: Int
    price: Float
}

type UpdateCartItemByIdResponse {
    id: String
}

input DeleteCartItemRequest {
    productId: String
    userId: String
}

type DeleteCartItemResponse {
    userId: String
}

input FindCartItemsWithPaginationRequest {
    productIds: [String]
    page: Int
    limit: Int
}

type FindCartItemsWithPaginationResponse {
    items: [CartItem]
    page: Int
    limit: Int
}
`, BuiltIn: false},
	{Name: "../schema/commerce/cart/v1/cartMutation.graphqls", Input: `extend type Mutation {
    createCartItem(input: CreateCartItemRequest): CreateCartItemResponse
    updateCartItemById(input: UpdateCartItemByIdRequest): UpdateCartItemByIdResponse
    deleteCartItem(input: DeleteCartItemRequest): DeleteCartItemResponse
}`, BuiltIn: false},
	{Name: "../schema/commerce/cart/v1/cartQuery.graphqls", Input: `extend type Query {
    findCartItemsWithPagination(input: FindCartItemsWithPaginationRequest): FindCartItemsWithPaginationResponse
}`, BuiltIn: false},
	{Name: "../schema/payment/v1/payment.graphqls", Input: `# Enums

enum PaymentStatus {
    PENDING
    PARTIAL
    SUCCESS
    FAILED
}

# Types

type PaymentItem {
    id: String!
    productId: String!
    amount: Float!
    qty: Int!
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

type Payment {
    id: String!
    code: String!
    items: [PaymentItem!]!
    totalPrice: Float!
    status: PaymentStatus!
    provider: Provider # Assuming Provider is defined elsewhere
    userId: String!
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

# Input Types (for Requests)

input CreatePaymentRequest {
    items: PaymentItemInput!
    userId: String!
    amount: Float!
}

input CallBackPaymentRequest {
    paymentId: String!
    amount: Float!
}

input FindPaymentByIdRequest {
    id: String!
}

input FindPaymentByUserIdAndStatusRequest {
    userId: String!
    status: PaymentStatus!
}

# Supporting Input Types

input PaymentItemInput {
    id: String!
    productId: String!
    amount: Float!
    qty: Int!
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}
`, BuiltIn: false},
	{Name: "../schema/payment/v1/paymentProvider.graphqls", Input: `# Enums

enum ProviderMethod {
    BANK
    CRYPTO_CURRENCY
    DEBIT
    CREDIT
    CASH_ON_DELIVERY
}

# Types

type Provider {
    id: String!
    name: String!
    method: ProviderMethod!
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

# Inputs for Queries

input FindPaymentProvidersRequest {
    name: String
}

# Outputs for Queries

type FindPaymentProvidersResponse {
    data: [Provider!]!
}`, BuiltIn: false},
	{Name: "../schema/payment/v1/paymentProviderQuery.graphqls", Input: `extend type Query {
    findPaymentProviders(input: FindPaymentProvidersRequest): FindPaymentProvidersResponse
}
`, BuiltIn: false},
	{Name: "../schema/payment/v1/paymentQuery.graphqls", Input: `extend type Query {
    findPaymentById(id: String!): Payment
    findPaymentByUserIdAndStatus(userId: String!, status: PaymentStatus!): Payment
}
`, BuiltIn: false},
	{Name: "../schema/product/v1/product.graphqls", Input: `scalar Time

type Product {
    id: ID!
    name: String!
    description: String!
    uom: String!
    image: String!
    price: Float!
    stock: Int!
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

type FindProductsWithPaginationResponse {
    data: [Product!]!
    limit: Int!
    page: Int!
    total: Int!
}

type DeleteProductByIdResponse {
    message: String!
}

input CreateProductRequest {
    name: String!
    description: String!
    uom: String!
    image: String!
    price: Float!
    stock: Int!
}

input UpdateProductByIdRequest {
    id: ID!
    name: String
    description: String
    uom: String
    image: String
    price: Float
    stock: Int
}

input FindProductsWithPaginationRequest {
    ids: [ID]
    name: [String!]
    page: Int!
    limit: Int!
}

type CreateProductResponse {
    id: ID!
}`, BuiltIn: false},
	{Name: "../schema/product/v1/productMutation.graphqls", Input: `extend type Mutation {
    createProduct(input: CreateProductRequest!): CreateProductResponse!
    updateProductById(input: UpdateProductByIdRequest!): Product!
    deleteProductById(id: ID!): DeleteProductByIdResponse!
}
`, BuiltIn: false},
	{Name: "../schema/product/v1/productQuery.graphqls", Input: `extend type Query {
    findProductsWithPagination(filter: FindProductsWithPaginationRequest!): FindProductsWithPaginationResponse!
    findProductById(id: String!): Product!
}`, BuiltIn: false},
	{Name: "../schema/user/v1/user.graphqls", Input: `type User {
    id: ID!
    name: String!
    email: String!
    password: String
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

input CreateUserRequest {
    name: String!
    email: String!
    password: String!
}

type CreateUserResponse {
    id : String!
}

input UpdateUserByIdRequest {
    id: String!
    name: String
    email: String
    password: String
}

type UpdateUserByIdResponse {
    id: String!
}

input FindUserByEmailAndPasswordRequest {
    email: String!
    password: String!
}`, BuiltIn: false},
	{Name: "../schema/user/v1/userMutation.graphqls", Input: `extend type Mutation {
    createUser(input: CreateUserRequest!): CreateUserResponse!
    updateUserById(input: UpdateUserByIdRequest!): UpdateUserByIdResponse
}`, BuiltIn: false},
	{Name: "../schema/user/v1/userQuery.graphqls", Input: `extend type Query {
    findUserById(id: String!): User
    findUserByEmailAndPassword(input: FindUserByEmailAndPasswordRequest!): User
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
