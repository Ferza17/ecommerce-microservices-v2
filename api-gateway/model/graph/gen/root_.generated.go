// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package gen

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	CreateProductResponse struct {
		ID func(childComplexity int) int
	}

	CreateUserPayload struct {
		ID func(childComplexity int) int
	}

	DeleteProductByIdResponse struct {
		Message func(childComplexity int) int
	}

	FindProductsWithPaginationResponse struct {
		Limit    func(childComplexity int) int
		Page     func(childComplexity int) int
		Products func(childComplexity int) int
	}

	Mutation struct {
		CreateProduct     func(childComplexity int, input CreateProductRequest) int
		CreateUser        func(childComplexity int, input CreateUserRequest) int
		DeleteProductByID func(childComplexity int, id string) int
		UpdateProductByID func(childComplexity int, input UpdateProductRequest) int
	}

	Product struct {
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		ID          func(childComplexity int) int
		Image       func(childComplexity int) int
		Name        func(childComplexity int) int
		Price       func(childComplexity int) int
		Stock       func(childComplexity int) int
		Uom         func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}

	Query struct {
		FindProductByID            func(childComplexity int, id string) int
		FindProductsWithPagination func(childComplexity int, filter FindProductsWithPaginationRequest) int
		FindUserByEmailAndPassword func(childComplexity int, input FindUserByEmailAndPasswordRequest) int
		FindUserByID               func(childComplexity int, input FindUserByIDRequest) int
	}

	User struct {
		CreatedAt   func(childComplexity int) int
		DiscardedAt func(childComplexity int) int
		Email       func(childComplexity int) int
		ID          func(childComplexity int) int
		Name        func(childComplexity int) int
		Password    func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "CreateProductResponse.id":
		if e.complexity.CreateProductResponse.ID == nil {
			break
		}

		return e.complexity.CreateProductResponse.ID(childComplexity), true

	case "CreateUserPayload.id":
		if e.complexity.CreateUserPayload.ID == nil {
			break
		}

		return e.complexity.CreateUserPayload.ID(childComplexity), true

	case "DeleteProductByIdResponse.message":
		if e.complexity.DeleteProductByIdResponse.Message == nil {
			break
		}

		return e.complexity.DeleteProductByIdResponse.Message(childComplexity), true

	case "FindProductsWithPaginationResponse.limit":
		if e.complexity.FindProductsWithPaginationResponse.Limit == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Limit(childComplexity), true

	case "FindProductsWithPaginationResponse.page":
		if e.complexity.FindProductsWithPaginationResponse.Page == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Page(childComplexity), true

	case "FindProductsWithPaginationResponse.products":
		if e.complexity.FindProductsWithPaginationResponse.Products == nil {
			break
		}

		return e.complexity.FindProductsWithPaginationResponse.Products(childComplexity), true

	case "Mutation.createProduct":
		if e.complexity.Mutation.CreateProduct == nil {
			break
		}

		args, err := ec.field_Mutation_createProduct_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateProduct(childComplexity, args["input"].(CreateProductRequest)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(CreateUserRequest)), true

	case "Mutation.deleteProductById":
		if e.complexity.Mutation.DeleteProductByID == nil {
			break
		}

		args, err := ec.field_Mutation_deleteProductById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteProductByID(childComplexity, args["id"].(string)), true

	case "Mutation.updateProductById":
		if e.complexity.Mutation.UpdateProductByID == nil {
			break
		}

		args, err := ec.field_Mutation_updateProductById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateProductByID(childComplexity, args["input"].(UpdateProductRequest)), true

	case "Product.createdAt":
		if e.complexity.Product.CreatedAt == nil {
			break
		}

		return e.complexity.Product.CreatedAt(childComplexity), true

	case "Product.description":
		if e.complexity.Product.Description == nil {
			break
		}

		return e.complexity.Product.Description(childComplexity), true

	case "Product.discardedAt":
		if e.complexity.Product.DiscardedAt == nil {
			break
		}

		return e.complexity.Product.DiscardedAt(childComplexity), true

	case "Product.id":
		if e.complexity.Product.ID == nil {
			break
		}

		return e.complexity.Product.ID(childComplexity), true

	case "Product.image":
		if e.complexity.Product.Image == nil {
			break
		}

		return e.complexity.Product.Image(childComplexity), true

	case "Product.name":
		if e.complexity.Product.Name == nil {
			break
		}

		return e.complexity.Product.Name(childComplexity), true

	case "Product.price":
		if e.complexity.Product.Price == nil {
			break
		}

		return e.complexity.Product.Price(childComplexity), true

	case "Product.stock":
		if e.complexity.Product.Stock == nil {
			break
		}

		return e.complexity.Product.Stock(childComplexity), true

	case "Product.uom":
		if e.complexity.Product.Uom == nil {
			break
		}

		return e.complexity.Product.Uom(childComplexity), true

	case "Product.updatedAt":
		if e.complexity.Product.UpdatedAt == nil {
			break
		}

		return e.complexity.Product.UpdatedAt(childComplexity), true

	case "Query.findProductById":
		if e.complexity.Query.FindProductByID == nil {
			break
		}

		args, err := ec.field_Query_findProductById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindProductByID(childComplexity, args["id"].(string)), true

	case "Query.findProductsWithPagination":
		if e.complexity.Query.FindProductsWithPagination == nil {
			break
		}

		args, err := ec.field_Query_findProductsWithPagination_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindProductsWithPagination(childComplexity, args["filter"].(FindProductsWithPaginationRequest)), true

	case "Query.findUserByEmailAndPassword":
		if e.complexity.Query.FindUserByEmailAndPassword == nil {
			break
		}

		args, err := ec.field_Query_findUserByEmailAndPassword_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUserByEmailAndPassword(childComplexity, args["input"].(FindUserByEmailAndPasswordRequest)), true

	case "Query.findUserById":
		if e.complexity.Query.FindUserByID == nil {
			break
		}

		args, err := ec.field_Query_findUserById_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.FindUserByID(childComplexity, args["input"].(FindUserByIDRequest)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.discardedAt":
		if e.complexity.User.DiscardedAt == nil {
			break
		}

		return e.complexity.User.DiscardedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.password":
		if e.complexity.User.Password == nil {
			break
		}

		return e.complexity.User.Password(childComplexity), true

	case "User.updatedAt":
		if e.complexity.User.UpdatedAt == nil {
			break
		}

		return e.complexity.User.UpdatedAt(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreateProductRequest,
		ec.unmarshalInputCreateUserRequest,
		ec.unmarshalInputFindProductsWithPaginationRequest,
		ec.unmarshalInputFindUserByEmailAndPasswordRequest,
		ec.unmarshalInputFindUserByIdRequest,
		ec.unmarshalInputUpdateProductRequest,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/product.graphqls", Input: `scalar Time

type Product {
    id: ID!
    name: String!
    description: String!
    uom: String!
    image: String!
    price: Float!
    stock: Int!
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

type FindProductsWithPaginationResponse {
    products: [Product!]!
    limit: Int!
    page: Int!
}

type DeleteProductByIdResponse {
    message: String!
}

input CreateProductRequest {
    name: String!
    description: String!
    uom: String!
    image: String!
    price: Float!
    stock: Int!
}

input UpdateProductRequest {
    id: ID!
    name: String
    description: String
    uom: String
    image: String
    price: Float
    stock: Int
}

input FindProductsWithPaginationRequest {
    ids: [ID!]
    name: [String!]
    page: Int!
    limit: Int!
}

type CreateProductResponse {
    id: ID!
}`, BuiltIn: false},
	{Name: "../schema/productMutation.graphqls", Input: `extend type Mutation {
    createProduct(input: CreateProductRequest!): CreateProductResponse!
    updateProductById(input: UpdateProductRequest!): Product!
    deleteProductById(id: ID!): DeleteProductByIdResponse!
}
`, BuiltIn: false},
	{Name: "../schema/productQuery.graphqls", Input: `extend type Query {
    findProductsWithPagination(filter: FindProductsWithPaginationRequest!): FindProductsWithPaginationResponse!
    findProductById(id: ID!): Product!
}`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `type User {
    id: ID!
    name: String!
    email: String!
    password: String
    createdAt: Time
    updatedAt: Time
    discardedAt: Time
}

input FindUserByIdRequest {
    id: ID!
}

input CreateUserRequest {
    name: String!
    email: String!
    password: String!
}

input FindUserByEmailAndPasswordRequest {
    email: String!
    password: String!
}

type CreateUserPayload {
    id: ID!
}
`, BuiltIn: false},
	{Name: "../schema/userMutation.graphqls", Input: `extend type Mutation {
    createUser(input: CreateUserRequest!): CreateUserPayload!
}`, BuiltIn: false},
	{Name: "../schema/userQuery.graphqls", Input: `extend type Query {
    findUserById(input: FindUserByIdRequest!): User
    findUserByEmailAndPassword(input: FindUserByEmailAndPasswordRequest!): User
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
