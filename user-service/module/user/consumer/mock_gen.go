// Code generated by mocktail; DO NOT EDIT.

package consumer

import (
	"context"
	"testing"
	"time"

	"github.com/stretchr/testify/mock"
)

// iUserConsumerMock mock of IUserConsumer.
type iUserConsumerMock struct{ mock.Mock }

// NewIUserConsumerMock creates a new iUserConsumerMock.
func NewIUserConsumerMock(tb testing.TB) *iUserConsumerMock {
	tb.Helper()

	m := &iUserConsumerMock{}
	m.Mock.Test(tb)

	tb.Cleanup(func() { m.AssertExpectations(tb) })

	return m
}

func (_m *iUserConsumerMock) UserCreated(_ context.Context) error {
	_ret := _m.Called()

	if _rf, ok := _ret.Get(0).(func() error); ok {
		return _rf()
	}

	_ra0 := _ret.Error(0)

	return _ra0
}

func (_m *iUserConsumerMock) OnUserCreated() *iUserConsumerUserCreatedCall {
	return &iUserConsumerUserCreatedCall{Call: _m.Mock.On("UserCreated"), Parent: _m}
}

func (_m *iUserConsumerMock) OnUserCreatedRaw() *iUserConsumerUserCreatedCall {
	return &iUserConsumerUserCreatedCall{Call: _m.Mock.On("UserCreated"), Parent: _m}
}

type iUserConsumerUserCreatedCall struct {
	*mock.Call
	Parent *iUserConsumerMock
}

func (_c *iUserConsumerUserCreatedCall) Panic(msg string) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Panic(msg)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) Once() *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Once()
	return _c
}

func (_c *iUserConsumerUserCreatedCall) Twice() *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Twice()
	return _c
}

func (_c *iUserConsumerUserCreatedCall) Times(i int) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Times(i)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) WaitUntil(w <-chan time.Time) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.WaitUntil(w)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) After(d time.Duration) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.After(d)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) Run(fn func(args mock.Arguments)) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Run(fn)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) Maybe() *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Maybe()
	return _c
}

func (_c *iUserConsumerUserCreatedCall) TypedReturns(a error) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Return(a)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) ReturnsFn(fn func() error) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Return(fn)
	return _c
}

func (_c *iUserConsumerUserCreatedCall) TypedRun(fn func()) *iUserConsumerUserCreatedCall {
	_c.Call = _c.Call.Run(func(args mock.Arguments) {
		fn()
	})
	return _c
}

func (_c *iUserConsumerUserCreatedCall) OnUserCreated() *iUserConsumerUserCreatedCall {
	return _c.Parent.OnUserCreated()
}

func (_c *iUserConsumerUserCreatedCall) OnUserUpdated() *iUserConsumerUserUpdatedCall {
	return _c.Parent.OnUserUpdated()
}

func (_c *iUserConsumerUserCreatedCall) OnUserCreatedRaw() *iUserConsumerUserCreatedCall {
	return _c.Parent.OnUserCreatedRaw()
}

func (_c *iUserConsumerUserCreatedCall) OnUserUpdatedRaw() *iUserConsumerUserUpdatedCall {
	return _c.Parent.OnUserUpdatedRaw()
}

func (_m *iUserConsumerMock) UserUpdated(_ context.Context) error {
	_ret := _m.Called()

	if _rf, ok := _ret.Get(0).(func() error); ok {
		return _rf()
	}

	_ra0 := _ret.Error(0)

	return _ra0
}

func (_m *iUserConsumerMock) OnUserUpdated() *iUserConsumerUserUpdatedCall {
	return &iUserConsumerUserUpdatedCall{Call: _m.Mock.On("UserUpdated"), Parent: _m}
}

func (_m *iUserConsumerMock) OnUserUpdatedRaw() *iUserConsumerUserUpdatedCall {
	return &iUserConsumerUserUpdatedCall{Call: _m.Mock.On("UserUpdated"), Parent: _m}
}

type iUserConsumerUserUpdatedCall struct {
	*mock.Call
	Parent *iUserConsumerMock
}

func (_c *iUserConsumerUserUpdatedCall) Panic(msg string) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Panic(msg)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) Once() *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Once()
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) Twice() *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Twice()
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) Times(i int) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Times(i)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) WaitUntil(w <-chan time.Time) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.WaitUntil(w)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) After(d time.Duration) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.After(d)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) Run(fn func(args mock.Arguments)) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Run(fn)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) Maybe() *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Maybe()
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) TypedReturns(a error) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Return(a)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) ReturnsFn(fn func() error) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Return(fn)
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) TypedRun(fn func()) *iUserConsumerUserUpdatedCall {
	_c.Call = _c.Call.Run(func(args mock.Arguments) {
		fn()
	})
	return _c
}

func (_c *iUserConsumerUserUpdatedCall) OnUserCreated() *iUserConsumerUserCreatedCall {
	return _c.Parent.OnUserCreated()
}

func (_c *iUserConsumerUserUpdatedCall) OnUserUpdated() *iUserConsumerUserUpdatedCall {
	return _c.Parent.OnUserUpdated()
}

func (_c *iUserConsumerUserUpdatedCall) OnUserCreatedRaw() *iUserConsumerUserCreatedCall {
	return _c.Parent.OnUserCreatedRaw()
}

func (_c *iUserConsumerUserUpdatedCall) OnUserUpdatedRaw() *iUserConsumerUserUpdatedCall {
	return _c.Parent.OnUserUpdatedRaw()
}
